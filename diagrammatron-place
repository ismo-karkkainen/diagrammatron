#!/usr/bin/env ruby

# Copyright 2021 Ismo Kärkkäinen
# Licensed under Universal Permissive License. See License.txt.

require 'optparse'
require 'yaml'
require 'set'
require 'pathname'

def info(msg)
  $stderr.puts(msg) unless $QUIET
end

def load_source
  begin
    if $INPUT.nil?
      src = YAML.load($stdin)
    else
      src = YAML.load(File.read($INPUT))
    end
  rescue Errno::ENOENT => e
    $stderr.puts "Could not load #{$INPUT.nil? ? 'stdin' : $INPUT}"
    return nil
  rescue StandardError => e
    $stderr.puts e.to_s
    $stderr.puts "Failed to read #{$INPUT.nil? ? 'stdin' : $INPUT}"
    return nil
  end
  return src
end

BoundingBox = Struct.new(:xmin, :ymin, :xmax, :ymax) do
  def merge(bb)
    return self if bb.nil?
    return BoundingBox.new(
      (xmin < bb.xmin) ? xmin : bb.xmin,
      (ymin < bb.ymin) ? ymin : bb.ymin,
      (xmax < bb.xmax) ? bb.xmax : xmax,
      (ymax < bb.ymax) ? bb.ymax : ymax
    )
  end

  def width
    return xmax - xmin
  end

  def height
    return ymax - ymin
  end

  def area
    return (xmax - xmin) * (ymax - ymin)
  end

  def short_side
    return [(xmax - xmin) * $W2HRATIO, (ymax - ymin)].min
  end

  def long_side
    return [(xmax - xmin) * $W2HRATIO, (ymax - ymin)].max
  end

  def overlap?(bb)
    return false if bb.nil?
    return false if bb.xmax <= xmin
    return false if xmax <= bb.xmin
    return false if bb.ymax <= ymin
    return false if ymax <= bb.ymin
    return true
  end

  def shift(dx, dy)
    self.xmin += dx
    self.ymin += dy
    self.xmax += dx
    self.ymax += dy
  end
end

Edge = Struct.new(:index, :sid, :path) do
  def bounding_box
    xs = path.map { |xy| xy['xo'] }
    ys = path.map { |xy| xy['yo'] }
    return BoundingBox.new(xs.min.floor, ys.min.floor, xs.max.floor, ys.max.floor)
  end

  def shift(dx, dy)
    path.each do |c|
      c['xo'] += dx
      c['yo'] += dy
    end
  end
end

Node = Struct.new(:index, :sid, :xo, :yo) do
  def bounding_box
    return BoundingBox.new(xo.floor, yo.floor, xo.floor, yo.floor)
  end

  def shift(dx, dy)
    self.xo += dx
    self.yo += dy
  end
end

def work_copy(src)
  work = { :edges => Hash.new, :nodes => Hash.new }
  # Expected nodes, edges. Other pass-through.
  nodes = src.fetch('nodes', [])
  nodes.each_index do |k|
    node = nodes[k]
    sid = node.fetch('sid', nil)
    xo = node.fetch('xo', nil)
    yo = node.fetch('yo', nil)
    next if sid.nil? or xo.nil? or yo.nil?
    work[:nodes][sid] = work[:nodes].fetch(sid, []).push(Node.new(k, sid, xo, yo))
  end
  edges = src.fetch('edges', [])
  edges.each_index do |k|
    edge = edges[k]
    path = edge.fetch('path', nil)
    sid = edge.fetch('sid', nil)
    next if path.nil? or sid.nil?
    work[:edges][sid] = work[:edges].fetch(sid, []).push(Edge.new(k, sid, path))
  end
  work[:subsets] = work[:nodes].keys.to_set.merge(work[:edges].keys.to_set).to_a
  return work
end

def bounding_box(work, sid)
  bb = nil
  [ :edges, :nodes ].each do |kind|
    work[kind].fetch(sid, []).each do |item|
      bb = item.bounding_box.merge(bb)
    end
  end
  bb.xmax += 1
  bb.ymax += 1
  return bb
end

def area_compare(b, a)
  d = a.area <=> b.area
  return d unless d == 0
  d = (a.xmax - a.xmin) <=> (b.xmax - b.xmin)
  return d unless d == 0
  return (a.ymax - a.ymin) <=> (b.ymax - b.ymin)
end

def area_order(bbs)
  order = []
  bbs.each_pair do |sid, bbox|
    order.push([sid, bbox])
  end
  order.sort! do |a, b|
    d = area_compare(a[1], b[1])
    (d != 0) ? d : (a[0] <=> b[0])
  end
  return order
end

def overlaps(state, cand)
  state.each_value do |s|
    return true if cand.overlap?(s)
  end
  return false
end

State = Struct.new(:state, :bbox, :used, :remaining_area) do
  def has_key?(sid_bbox)
    return state.has_key? sid_bbox.first
  end

  def can_improve?(small)
    return true if small.nil?
    must_add = [ remaining_area - (bbox.area - used), 0 ].max
    return bbox.area + must_add < small.bbox.area
  end
end

def depth_first_search(order, state, small, reverse = false)
  if state.state.size < order.size
    return small unless state.can_improve? small
    # Loop over all sids not in state and the loop over false, true.
    prev = nil
    order.each do |sb|
      next if state.has_key? sb
      next if sb[1] == prev
      prev = sb[1]
      state.state.each_value do |n|
        [false, true].each do |right|
          right = not(right) if reverse
          cand = sb[1].clone
          cand.shift(right ? n.xmax : n.xmin, right ? n.ymin : n.ymax)
          next if overlaps(state.state, cand) # Invalid state.
          # Did we create a worse solution?
          bc = state.bbox.merge(cand)
          unless small.nil?
            d = small.bbox.long_side <=> bc.long_side
            next if d == -1
            next if d == 0 and small.bbox.short_side <= bc.short_side
          end
          s = state.state.clone
          s[sb[0]] = cand
          a = sb[1].area
          small = depth_first_search(order,
            State.new(s, bc, state.used + a, state.remaining_area - a),
            small, not(reverse))
        end
      end
    end
  else # We compared with area before call so no need to do it here.
    small = State.new(state.state.clone, state.bbox.clone, state.used, 0)
    info("Found (#{state.bbox.width}, #{state.bbox.height})")
  end
  return small
end

def dumb_depth_first_search(bbs)
  order = area_order(bbs)
  remains = (order.map { |sb| sb[1].area }).sum
  unless $QUIET
    sizes = [ order[0][1] ]
    (1...order.size).each do |k|
      next if order[k - 1][1] == order[k][1]
      sizes.push(order[k][1])
    end
    sizes = sizes.map { |b| "(#{b.width}, #{b.height})" }
    info("#{order.size} sub-diagrams total area #{remains} in sizes #{sizes.join(' ')}")
  end
  # At top level try only widest and tallest as in other places they can swap
  # with a block of others in other locations.
  widest = 0
  tallest = 0
  (1...order.size).each do |k|
    widest = k if order[widest][1].width < order[k][1].width
    tallest = k if order[tallest][1].height < order[k][1].height
  end
  small = nil
  ((widest == tallest) ? [ widest ] : [ widest, tallest ]).each do |k|
    info("Top-level candidate #{k + 1}")
    sb = order[k]
    a = sb[1].area
    small = depth_first_search(order,
      State.new({ sb[0] => sb[1].clone }, sb[1], a, remains - a), small)
  end
  return small.state # State is sid to final bbox mapping.
end

def shift(work, sid, dx, dy)
  [ :edges, :nodes ].each do |kind|
    work[kind].fetch(sid, []).each do |item|
      item.shift(dx, dy)
    end
  end
end

def place_subsets(work)
  bbs = Hash.new
  original = Hash.new
  work[:subsets].each do |sid|
    bb = bounding_box(work, sid)
    original[sid] = bb.clone
    bb.shift(-bb.xmin, -bb.ymin) # Ensure the corner is at (0, 0)
    bbs[sid] = bb
  end
  bbs = dumb_depth_first_search(bbs)
  # Shift everything in each subset according to shift compared to original.
  original.each_pair do |sid, bbox|
    shifted = bbs[sid]
    shift(work, sid, shifted.xmin - bbox.xmin, shifted.ymin - bbox.ymin)
  end
end

def prepare_output(doc, work)
  work[:nodes].each_pair do |sid, nodes|
    nodes.each do |node|
      doc['nodes'][node.index]['xo'] = node.xo
      doc['nodes'][node.index]['yo'] = node.yo
    end
  end
  work[:edges].each_pair do |sid, edges|
    edges.each do |edge|
      doc['edges'][edge.index]['path'] = edge.path
    end
  end
end

$INPUT = nil
$OUTPUT = nil
$W2HRATIO = 1.0
$QUIET = false

def main
  parser = OptionParser.new do |opts|
    opts.summary_indent = '  '
    opts.summary_width = 26
    opts.banner = "Usage: diagrammatron-place [options]"
    opts.separator ""
    opts.separator "Options:"
    opts.on('-r', '--ratio VALUE', 'Node width to height ratio. Default 1.0.') do |value|
      $W2HRATIO = value
    end
    opts.on('-i', '--input FILE', 'Input file name. By default stdin.') do |filename|
      $INPUT = filename
    end
    opts.on('-o', '--output FILE', 'Output file name. By default stdout.') do |filename|
      $OUTPUT = filename
    end
    opts.on('-q', '--quiet', 'No output except errors.') do
      $QUIET = true
    end
    opts.on('-h', '--help', 'Print this help and exit.') do
      $stdout.puts opts
      $stdout.puts %Q(
Input YAML file is expected to be the output of diagrammatron-edges.

Output is the input file with 'xo' and 'yo' modified so that the sub-diagrams
do not overlap.
)
      exit 0
    end
  end
  parser.parse! ARGV
  unless $W2HRATIO.is_a? Float
    begin
      whratio = Float($W2HRATIO)
      if whratio <= 0
        $stderr.puts "Ratio must be greater than zero: #{$W2HRATIO}"
        exit 1
      end
      $W2HRATIO = whratio
    rescue StandardError
      $stderr.puts "Ratio parameter not a number: #{$W2HRATIO}"
      exit 1
    end
  end

  doc = load_source
  exit(2) if doc.nil?

  begin
    work = work_copy(doc)
  rescue StandardError
    work = nil
    $stderr.puts "Error processing input."
  end
  exit(3) if work.nil?

  # Eventually support more algorithms?
  place_subsets(work)
  prepare_output(doc, work)
  begin
    if $OUTPUT.nil?
      $stdout.puts YAML.dump(doc)
    else
      fp = Pathname.new $OUTPUT
      fp.open('w') do |f|
        f.puts YAML.dump(doc)
      end
    end
  rescue StandardError => e
    $stderr.puts e.to_s
    $stderr.puts "Failed to write output: #{$OUTPUT}"
    exit 4
  end
end

if (defined? $unit_test).nil?
  main
end
